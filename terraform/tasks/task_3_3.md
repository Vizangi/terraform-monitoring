### Уровень 4: Подведение итогов и следующий шаг

На этом этапе мы подводим итоги первых трёх уровней Terraform-проекта и планируем дальнейшие шаги. Вы научились создавать инфраструктуру с Docker для сред разработки (dev), тестирования (staging) и продакшена (prod), используя Docker-сети (аналог VPC) и контейнеры (Nginx для веб-сервера, PostgreSQL для базы данных). Теперь мы оценим достижения, выявим проблему текущего подхода и подготовимся к использованию модулей на следующем уровне.

#### Чему вы научились
- **Уровень 1**: Создали одну среду (dev) с сетью (`dev-network`), веб-сервером (`dev-web`) и базой данных (`dev-db`). Освоили основы Terraform: провайдер, ресурсы, переменные.
- **Уровень 2**: Добавили staging и prod, скопировав код для dev. Увидели, как дублирование кода усложняет поддержку.
- **Уровень 3**: Упростили управление настройками, используя переменную `environments` типа `map`, чтобы хранить параметры всех сред в одном месте.

#### Проблема
В файле `main.tf` (Уровень 3) код для каждой среды (dev, staging, prod) повторяется: блоки для сетей (`docker_network`) и контейнеров (`docker_container`) почти идентичны, различаясь только именами, портами и пользователями. Это:
- Делает код длинным и трудночитаемым.
- Усложняет добавление новых сред (например, `test`), так как нужно копировать блоки в `main.tf`.
- Затрудняет внесение изменений, если нужно обновить логику для всех сред.

#### Следующий шаг
Для продвинутых студентов следующий шаг — изучить **модули** и **циклы** (`for_each`):
- **Модули**: Выделите код для создания сети и контейнеров в отдельную папку `modules/environment`. Это позволит переиспользовать логику для каждой среды, передавая параметры (например, `env_name = "dev"`, `web_port = 8080`).
- **Циклы (`for_each`)**: Используйте `for_each` с переменной `environments`, чтобы Terraform автоматически создавал ресурсы для всех сред, перебирая ключи `map` (dev, staging, prod).

Мы реализуем эти улучшения на **Уровне 5**, чтобы устранить дублирование кода и сделать проект более гибким. Пока же структура остаётся прежней, и мы не меняем файлы, чтобы закрепить текущие знания.

#### Структура проекта
```
terraform-docker-course/
├── main.tf
├── variables.tf
└── terraform.tfvars
```
- **Файлы**: Используются файлы из Уровня 3 (`main.tf`, `variables.tf`, `terraform.tfvars`). Никаких изменений не вносится.
- **Примечание**: На Уровне 4 мы не добавляем новых файлов, так как фокусируемся на анализе и планировании.

#### Как запустить
На Уровне 4 вы работаете с кодом из Уровня 3, чтобы протестировать или поэкспериментировать:
1. **Убедитесь, что файлы готовы**:
   - Используйте `main.tf`, `variables.tf`, `terraform.tfvars` из Уровня 3 (включены в артефакт ниже).
   - Убедитесь, что Docker и Terraform установлены.
2. **Инициализация**:
   ```bash
   terraform init
   ```
3. **Применение**:
   ```bash
   terraform apply
   ```
4. **Проверка**:
   - Откройте в браузере:
     - `http://localhost:8080` (dev, Nginx).
     - `http://localhost:8081` (staging).
     - `http://localhost:8082` (prod).
   - Проверьте базы данных:
     ```bash
     docker exec -it dev-db psql -U dev_user -d dev_db
     docker exec -it staging-db psql -U staging_user -d staging_db
     docker exec -it prod-db psql -U prod_user -d prod_db
     ```
5. **Удаление**:
   ```bash
   terraform destroy
   ```

#### Задания для студентов
- **Эксперимент**: Добавьте среду `test` в `terraform.tfvars` (например, `web_port = 8083`, `db_user = "test_user"`) и скопируйте блоки для `test_network`, `test_web`, `test_db` в `main.tf`. Это покажет неудобство дублирования.
- **Исследование**: Прочитайте в документации Terraform про `for_each` и модули. Подумайте, как можно сократить `main.tf`, используя цикл.

---
